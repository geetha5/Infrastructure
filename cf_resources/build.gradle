import groovy.json.*

buildscript {
    ext {
    }
    repositories {
        jcenter()
        mavenCentral()
    }
    dependencies {
    }
}

ext {
    // cloudformation resource name
    resourceName = loadStringProp("resourceName", "kinesis_encryption")
    // resource version
    resourceVersion = getResourceVersion(resourceName)
    // S3 Properties
    s3KeyBase = loadStringProp("s3KeyBase", "cf_resources")
    s3KeyBaseWithResource = "${s3KeyBase}/${resourceName}"
    // The build to promote
    buildToPromote = loadStringProp("buildToPromote", "latest")
    // The version to promote too
    promotedVersion = loadStringProp("promotedVersion", "0.0.1")
}

// Common Tasks //
task clean(type:Task) {
    description = "Cleans the build directory and temp directory if they exist"
    group = "Common"

    doLast {
        new File(projectDir, "${resourceName}/build").deleteDir()
        new File(projectDir, "${resourceName}/temp").deleteDir()
        new File(projectDir, "${resourceName}/test/lib").deleteDir()
    }
}

// Test Tasks //
task createTestLibDir(type:Task) {
    description = "Creates a lib directory for lambda local testing"
    group = "Test"

    doLast {
        new File(projectDir, "${resourceName}/test/lib").mkdirs()
    }
}

task cleanTestLibDir(type:Task) {
    description = "Removes the lib directory for lambda local testing"
    group = "Test"

    doLast {
        new File(projectDir, "${resourceName}/test/lib").deleteDir()
    }
}

task setupTesting(type:Task) {
    description = "Setup the resource for local lambda testing"
    group = "Test"

    dependsOn 'cleanTestLibDir'
    dependsOn 'createTestLibDir'

    doLast {
        File requirementsFile = new File(projectDir, "/${resourceName}/requirements.txt")
        File libDir = new File(projectDir, "${resourceName}/test/lib")

        // pip install the requirements file
        logger.lifecycle("pip installing dependencies from requirements file\n")
        boolean pipResult = pipInstallRequirements(requirementsFile, libDir)

        if (!pipResult) {
            throw new GradleException("pip install of requirements was not successful\n")
        }

        // pip install common included libs
        logger.lifecycle("pip installing common provided libraries")
        pipResult = pipInstallTestingCommon(libDir)

        if (!pipResult) {
            throw new GradleException("pip install of common libs was not successful")
        }
    }
}

// Build Tasks //
task createBuildDir(type:Task) {
    description = "Creates the build directory"
    group = "Build"

    doLast {
        new File(projectDir, "/${resourceName}/build").mkdir()
    }
}

task cleanBuildDir(type:Task) {
    description = "Cleans the build directory if it exists"
    group = "Build"

    doLast {
        new File(projectDir, "${resourceName}/build").deleteDir()
    }
}

task createPackageDir(type:Task) {
    description = "Creates the package directory in the build directory"
    group = "Build"

    doLast {
        new File(projectDir, "${resourceName}/build/package").mkdir()
    }
}

task getDeps(type:Task) {
    description = "Builds the lambda package"
    group = "Build"

    dependsOn 'cleanBuildDir'
    dependsOn 'createBuildDir'
    dependsOn 'createPackageDir'

    doLast {

        // pip install to package directory
        logger.lifecycle("Pip installing dependencies")
        File requirementsFile = new File(projectDir, "${resourceName}/requirements.txt")
        File packageDir = new File(projectDir, "${resourceName}/build/package")
        boolean pipResult = pipInstallRequirements(requirementsFile, packageDir)

        if (!pipResult) {
            throw new GradleException("pip install was not successful")
        }
    }
}

task copySourceFiles(){
    description = "Copies the lambda source files to package directory"
    group = "Build"

    dependsOn 'getDeps'

    outputs.upToDateWhen{ false }

    doLast {
        copy {
            from "${resourceName}"
            into "${resourceName}/build/package"
            include "*.py"
        }
    }
}

task zipPackage(type:Zip) {
    description = "Creates the zip package of the lambda"
    group = "Build"

    dependsOn 'copySourceFiles'

    destinationDir = new File(projectDir, "${resourceName}/build")
    archiveName = "${resourceName}.zip"
    from fileTree("${resourceName}/build/package")

    outputs.upToDateWhen { false }
}

task build(type:Task) {
    description = "Uploads the zip Lambda to s3"
    group = "Build"

    dependsOn 'zipPackage'

    doLast {
        // Get the current timestamp (UTC) and create the base s3Key fro the build
        String buildTimestamp = new Date().format("yyyyMMdd-HHmmss", TimeZone.getTimeZone("UTC"))

        logger.lifecycle("Making build ${resourceVersion}_${buildTimestamp} for resource ${resourceName}")

        String buildS3Key = "${s3KeyBaseWithResource}/dev/${resourceVersion}_${buildTimestamp}"
        String latestS3Key = "${s3KeyBaseWithResource}/dev/latest.txt"
        File latestFile = new File(projectDir, "${resourceName}/build/latest.txt")
        File metadataFile = new File(projectDir, "${resourceName}/build/metadata.json")

        // Write and upload latest tag file
        latestFile << "${resourceVersion}_${buildTimestamp}"
        uploadToS3(s3Bucket, latestS3Key, "cf_resources/${resourceName}/build/latest.txt", false)

        // Upload resource zip
        uploadToS3(s3Bucket, "${buildS3Key}/${resourceName}.zip", "cf_resources/${resourceName}/build/${resourceName}.zip", false)

        // Create and upload metadata file
        String json = JsonOutput.toJson([gitHash: gitHash, gitBranch: gitBranch])
        metadataFile << json
        uploadToS3(s3Bucket, "${buildS3Key}/metadata.json", metadataFile.absolutePath, false)

        logger.lifecycle("Created build s3://${s3Bucket}/${buildS3Key}")
        logger.lifecycle("resource zip s3://${s3Bucket}/${buildS3Key}/${resourceName}.zip")
    }
}

// Promote Tasks //
task createTempDir(type:Task) {
    description = "Creates the Temp directory for artifact promotion"
    group = "Promote"

    doLast {
        new File(projectDir, "${resourceName}/temp").mkdir()
    }
}

task cleanTempDir(type:Task) {
    description = "Cleans the temp directory if it exists"
    group = "Promote"

    doLast {
        new File(projectDir, "${resourceName}/temp").deleteDir()
    }
}

task promoteBuild(type:Task) {
    description = "Promote a build to a version"
    group = "Promote"

    dependsOn 'cleanTempDir'
    dependsOn 'createTempDir'

    doLast {
        String buildNumberToPromote

        if (buildToPromote == "latest") {
            buildNumberToPromote = getLatestBuild("${s3KeyBaseWithResource}/dev/latest.txt", "cf_resources/${resourceName}/temp")

            if (!checkForS3Object(s3Bucket, "${s3KeyBaseWithResource}/dev/${buildNumberToPromote}/${resourceName}.zip")) {
                throw new GradleException("Build to promote ${buildNumberToPromote} doesn't exist")
            }

            logger.lifecycle("Promoting ${resourceName} latest build: ${buildNumberToPromote}")
        }
        else {
            buildNumberToPromote = buildToPromote

            if (!checkForS3Object(s3Bucket, "${s3KeyBaseWithResource}/dev/${buildNumberToPromote}/${resourceName}.zip")) {
                throw new GradleException("Build to promote ${buildNumberToPromote} doesn't exist")
            }
        }

        if (checkForS3Object(s3Bucket, "${s3KeyBaseWithResource}/releases/${promotedVersion}/${resourceName}.zip")) {
            throw new GradleException("Version: ${promotedVersion} already exists")
        }

        logger.lifecycle("Promoting ${resourceName} build ${buildNumberToPromote} to version ${promotedVersion}")

        String sourceS3Key = "${s3KeyBaseWithResource}/dev/${buildNumberToPromote}"
        String tempLocation = "cf_resources/${resourceName}/temp/${buildNumberToPromote}"
        String uploadTemp = "cf_resources/${resourceName}/temp/${buildNumberToPromote}/${s3KeyBaseWithResource}/dev/${buildNumberToPromote}"
        String destS3Key = "${s3KeyBaseWithResource}/releases/${promotedVersion}"
        downloadFromS3(s3Bucket, sourceS3Key, tempLocation, true)
        uploadToS3(s3Bucket, destS3Key, uploadTemp, true)

        logger.lifecycle("promoted build s3://${s3Bucket}/${s3KeyBaseWithResource}/releases/${promotedVersion}")
        logger.lifecycle("promoted zip s3://${s3Bucket}/${s3KeyBaseWithResource}/releases/${promotedVersion}/${resourceName}.zip")
    }
}

// Functions //
/**
 * This will get the version of the resource from the
 * version.txt file in the resource directory
 * @param resourceName the name of the resource
 * @return the version of the resource
 */
String getResourceVersion(String resourceName) {
    String version = new File(projectDir, "${resourceName}/version.txt").text
    return version
}

/**
 * This will run a pip install to install lambda dependencies, this will only run if
 * there is a requirements.txt file present
 * @param requirementsFilePath the file name and path of the requirements.txt file
 * @param installDirPath the install directory to install the dependencies in
 * @return a boolean of if the commmand was successful or not
 */
boolean pipInstallRequirements(File requirementsFile, File installDir) {

    // if the requirements file doesn't exist return true
    if (!requirementsFile.exists()) {
        logger.debug("no requirements file present skipping")
        return true
    }
    else {
        List<String> pipCmd = [
                "pip",
                "--disable-pip-version-check",
                "install",
                "-r",
                "${requirementsFile.absolutePath}",
                "-t",
                "${installDir.absolutePath}"
        ]

        StringBuilder sout = new StringBuilder()
        StringBuilder serr = new StringBuilder()
        Process p = pipCmd.execute()
        p.consumeProcessOutput(sout, serr)
        p.waitFor()

        logger.debug("System out: ${sout}")
        logger.debug("System err: ${serr}")

        if (p.exitValue() != 0) {
            return false
        }
        return true
    }
}

/**
 * This will download common libraries already included with lambda
 * @param libDir the name and path to the library dir for testing
 * @return a boolean of if the command was successful or not
 */
boolean pipInstallTestingCommon(File libDir) {

    List<String> commonPackages = ["boto3"]
    boolean failureFlag = false

    for (commonPackage in commonPackages) {
        logger.lifecycle("installing common package ${commonPackage}")

        List<String> pipCmd = [
                "pip",
                "--disable-pip-version-check",
                "install",
                "${commonPackage}",
                "-t",
                "${libDir.absolutePath}"
        ]

        StringBuilder sout = new StringBuilder()
        StringBuilder serr = new StringBuilder()
        Process p = pipCmd.execute()
        p.consumeProcessOutput(sout, serr)
        p.waitFor()

        logger.debug("System out: ${sout}")
        logger.debug("System err: ${serr}")

        if (p.exitValue() != 0) {
            failureFlag = true
        }
    }

    if (failureFlag) {
        return false
    }
    return true
}
